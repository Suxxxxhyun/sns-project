## pull mode, push model

- 타임라인을 구현하는 방법에는 총2가지가 있다.
  - 이때, 타임라인은, 인스타그램, 페이스북, 트위터와 같은 sns의 메인 피드를 의미한다.
  - fanout : 사용자가 게시물을 작성하였을 때, 이 글을 봐야하는 모든 사람들(인스타그램의 팔로워, 페이스북 친구 등)에게 전달하는 과정
  
  - **push model(fanout-on-write)** : **쓰기 시점에 fanout하는 것**을 의미한다.
    - 즉, 사용자 1명이 게시글을 적을 때마다, 자신의 팔로워 모두에게 해당 글을 전파한다.
  - **pull model(fanout-on-read)** : **읽기 시점에 fanout하는 것**을 의미한다.
    - 게시글을 적을 때는 별 동작이 없다가, 팔로워 1명이 새로고침하는 시점에 그 사람의 피드만 갱신한다.
    - 따라서 on-demand모델이며, Lazy하다고 표현할 수 있다.
  
### push mode(fanout-on-write)
- 사용자 A가 새 글을 기록할 때마다 A의 친구 목록에 있는 모두에게 글이 전송된다.
- 장점
  - 피드가 실시간으로 갱신된다.
  - 피드를 읽는데 드는 시간이 짧아진다. 새 포스팅이 기록되는 순간, 피드가 이미 수정되기 때문이다.
- 단점
  - Hotkey problem(핫 키 문제)
    - 친구가 많은 사용자의 경우(ex: justin biber), 그 목록에 있는 모든 사람의 피드를 갱신하는데 오랜시간이 걸린다.
    - 서비스를 자주 사용하지 않는 사람의 피드까지 갱신해야하기때문에 컴퓨팅 자원이 낭비될 수 있다.

### pull model(fanout-on-read)
- 사용자 A가 피드를 읽을 때마다 새로운 글을 가져와서 A의 피드를 갱신한다.
- 장점
  - 자주 접속하지 않는 사용자가 꽤 많다면, 이 모델이 더 유리하다.
  - 로그인해서 피드를 새로고침하기 전까지 그 어떤 자원도 사용되지 않기 때문이다.
  - 핫 키 문제가 발생하지 않는다.
- 단점
  - 피드를 읽는 시간이 비교적 오래 걸린다. 로그인해서 피드를 새로고침하는 순간, 피드를 수정해야하기 때문이다.

- 참조블로그
  - https://velog.io/@broccolism/%ED%8A%B8%EC%9C%84%ED%84%B0-%EC%9D%B8%EC%8A%A4%ED%83%80%EA%B7%B8%EB%9E%A8-%ED%94%BC%EB%93%9C%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A7%88%EA%B9%8C-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EA%B3%84-%EA%B8%B0%EC%B4%88-11%EC%9E%A5